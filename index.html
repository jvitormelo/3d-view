<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Scene for GitHub README</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        overflow: hidden;
        font-family: "Arial", sans-serif;
      }

      #container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        z-index: 100;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      #canvas {
        display: block;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 24px;
        z-index: 50;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="info">
        <h2>Interactive 3D Scene</h2>
        <p>Drag to rotate â€¢ Scroll to zoom</p>
      </div>
      <div class="loading" id="loading">Loading 3D Scene...</div>
      <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("canvas"),
        antialias: true,
        alpha: true,
      });

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Create floating geometric shapes
      const shapes = [];
      const geometries = [
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.SphereGeometry(0.7, 32, 32),
        new THREE.ConeGeometry(0.7, 1.5, 8),
        new THREE.OctahedronGeometry(0.8),
        new THREE.TorusGeometry(0.6, 0.3, 16, 32),
      ];

      const colors = [
        0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xf0932b, 0xeb4d4b, 0x6c5ce7,
      ];

      for (let i = 0; i < 15; i++) {
        const geometry =
          geometries[Math.floor(Math.random() * geometries.length)];
        const material = new THREE.MeshLambertMaterial({
          color: colors[Math.floor(Math.random() * colors.length)],
          transparent: true,
          opacity: 0.8,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20
        );
        mesh.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Add random animation properties
        mesh.userData = {
          rotationSpeed: {
            x: (Math.random() - 0.5) * 0.02,
            y: (Math.random() - 0.5) * 0.02,
            z: (Math.random() - 0.5) * 0.02,
          },
          floatSpeed: Math.random() * 0.02 + 0.01,
          floatOffset: Math.random() * Math.PI * 2,
        };

        shapes.push(mesh);
        scene.add(mesh);
      }

      // Position camera
      camera.position.z = 15;
      camera.position.y = 5;
      camera.lookAt(0, 0, 0);

      // Mouse controls
      let mouseX = 0;
      let mouseY = 0;
      let targetX = 0;
      let targetY = 0;
      let isMouseDown = false;

      document.addEventListener("mousemove", (event) => {
        if (isMouseDown) {
          mouseX = (event.clientX / window.innerWidth) * 2 - 1;
          mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }
      });

      document.addEventListener("mousedown", () => {
        isMouseDown = true;
      });

      document.addEventListener("mouseup", () => {
        isMouseDown = false;
      });

      // Zoom controls
      document.addEventListener("wheel", (event) => {
        camera.position.z += event.deltaY * 0.01;
        camera.position.z = Math.max(5, Math.min(30, camera.position.z));
      });

      // Touch controls for mobile
      let touchStartX = 0;
      let touchStartY = 0;

      document.addEventListener("touchstart", (event) => {
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
      });

      document.addEventListener("touchmove", (event) => {
        event.preventDefault();
        const touchX = event.touches[0].clientX;
        const touchY = event.touches[0].clientY;

        mouseX += (touchX - touchStartX) * 0.005;
        mouseY += (touchY - touchStartY) * 0.005;

        touchStartX = touchX;
        touchStartY = touchY;
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Smooth camera rotation
        targetX = mouseX * 0.5;
        targetY = mouseY * 0.5;

        camera.position.x += (targetX - camera.position.x) * 0.05;
        camera.position.y += (targetY - camera.position.y) * 0.05;
        camera.lookAt(0, 0, 0);

        // Animate shapes
        shapes.forEach((shape, index) => {
          // Rotation animation
          shape.rotation.x += shape.userData.rotationSpeed.x;
          shape.rotation.y += shape.userData.rotationSpeed.y;
          shape.rotation.z += shape.userData.rotationSpeed.z;

          // Floating animation
          const time = Date.now() * 0.001;
          shape.position.y +=
            Math.sin(
              time * shape.userData.floatSpeed + shape.userData.floatOffset
            ) * 0.02;
        });

        renderer.render(scene, camera);
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Hide loading message and start animation
      document.getElementById("loading").style.display = "none";
      animate();
    </script>
  </body>
</html>
